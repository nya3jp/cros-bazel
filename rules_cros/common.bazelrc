# Assume we're building on x86_64 Linux for now.
build --host_platform @rules_cros//cros/platforms:linux_x86_64

# Use the target platform in the bazel-out/ output directory name fragment
# instead of the CPU (darwin, k8). This avoids thrashing the output directory
# when switching between top level target --platforms values.
build --experimental_platform_in_output_dir

# Use the JDK provided by the CrOS SDK instead of trying to download a bundled
# remote JDK.
build --tool_java_runtime_version=11

# Use toolchain resolution to find the cc toolchain.
build --incompatible_enable_cc_toolchain_resolution

# Enable usage of experimental cc-related build APIs
build --experimental_starlark_cc_import
build --experimental_repo_remote_exec

# Disable local cpp toolchain detection, as we declare it explicitly.
build --action_env=BAZEL_DO_NOT_DETECT_CPP_TOOLCHAIN=1

# Declare a cc_toolchain_suite to work around 
# https://github.com/bazelbuild/bazel/issues/12712
build --crosstool_top="@rules_cros//cros/toolchain/cc:cros-cc-toolchain-suite"

# Lock down the PATH variable in actions to /usr/bin and /usr/local/bin.
build --experimental_strict_action_env

# Do not tokenize copts, other than strings that consist of a single Make
# variable.  This prevents the need to double-escape characters like backslashes
# and quotes in copts.
build --features no_copts_tokenization

# Support a local user-specific bazelrc file.
try-import %workspace%/user.bazelrc
