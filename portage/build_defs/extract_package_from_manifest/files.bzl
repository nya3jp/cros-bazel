# Copyright 2023 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

visibility("private")

ExtractedFileInfo = provider(
    fields = dict(
        path = "str: Absolute path to the file",
        file = "File: The file generated by this target",
        runfiles = "depset[File]: The files required to run this target",
        file_type = "Union[UnknownInfo, SymlinkInfo, HeaderFileInfo, SharedLibraryInfo, ElfBinaryInfo]: A provider version of package::FileType",
        file_type_name = "str: One of the constants below for the file type.",
    ),
)

# This is a copy of each entry in the enum FileType in
# bazel/portage/bin/extract_package_from_manifest/package/src/package.rs.
UNKNOWN = "Unknown"
UnknownInfo = provider(fields = dict())

SYMLINK = "Symlink"
SymlinkInfo = provider(fields = dict(
    target = "ExtractedFileInfo: The target file's metadata",
))

HEADER = "HeaderFile"
HeaderFileInfo = provider(fields = dict())

SHARED_LIBRARY = "SharedLibrary"
SharedLibraryInfo = provider(fields = dict())

ELF_BINARY = "ElfBinary"
ElfBinaryInfo = provider(fields = dict(
    interp = "ExtractedFileInfo: The interpreter of the binary",
    libs = "depset[ExtractedFileInfo]: libraries required to run the binary",
    rpath = "list[str]: The rpath for the binary",
    runpath = "list[str]: The runpath for the binary",
))

_CONSTRUCTORS = {
    UNKNOWN: UnknownInfo,
    SYMLINK: SymlinkInfo,
    HEADER: HeaderFileInfo,
    SHARED_LIBRARY: SharedLibraryInfo,
    ELF_BINARY: ElfBinaryInfo,
}

def preprocess_content(content):
    """
    Ensures that if an elf binary depends on a symlink to a shared library,
    then we process the shared library, then the symlink, then the elf binary.
    It's impossible to construct the elf binary provider until the other two
    have been generated.
    """
    unprocessed = {k: v for k, v in content.items()}
    result = []
    for _ in range(len(content)):
        if not unprocessed:
            break

        # Avoid iterating while modifying, and make it deterministic for testing.
        unprocessed_paths = sorted(unprocessed.keys())
        for path in unprocessed_paths:
            # Copy it so we can mutate
            metadata = dict(**unprocessed[path])
            file_type = metadata["type"]
            if file_type == SYMLINK and metadata["target"] in unprocessed:
                continue
            if file_type == ELF_BINARY:
                metadata.setdefault("interp", "/lib64/ld-linux-x86-64.so.2")
                metadata.setdefault("libs", [])
                metadata["rpath"] = tuple(metadata.get("rpath", []))
                metadata["runpath"] = tuple(metadata.get("runpath", []))
                if metadata["interp"] in unprocessed:
                    continue
                if any([lib in unprocessed for lib in metadata["libs"].values()]):
                    continue
            unprocessed.pop(path)
            result.append((path, metadata))

    if unprocessed:
        fail("This should never happen. Got %r" % unprocessed)
    return result

def get_extracted_files(ctx, files, content):
    """Calculate ExtractedFileInfo for a given manifest.

    Args:
      files: dict[str, ExtractedFileInfo]: Mapping from files to their
        providers. Entries are added to this dictionary.
      content: dict[str, any]: Mapping from file to serialized package.

    Returns the subset of files that were added in this function call, and the
    files that will be generated by this package.
    """
    extra_files = []
    generated = []

    for f, kwargs in preprocess_content(content):
        out_path = f.strip("/")
        file_type = kwargs.pop("type")

        if file_type == SYMLINK:
            out = ctx.actions.declare_symlink(out_path)
        else:
            out = ctx.actions.declare_file(out_path)
        generated.append(out)

        runfiles = [depset([out])]

        def path_to_file(path):
            file = files[path]
            runfiles.append(file.runfiles)
            return file

        if file_type == SYMLINK:
            if kwargs["target"] in files:
                kwargs["target"] = path_to_file(kwargs["target"])
            else:
                # This is probably a symlink to a directory.
                file_type = UNKNOWN
                kwargs = {}
        elif file_type == ELF_BINARY:
            kwargs["interp"] = path_to_file(kwargs["interp"])
            kwargs["libs"] = depset([
                path_to_file(lib)
                for lib in kwargs["libs"].values()
            ])

            elf = ctx.actions.declare_file(out_path + ".elf")
            runfiles.append(depset([elf]))
            generated.append(elf)

        info = ExtractedFileInfo(
            path = f,
            file = out,
            file_type_name = file_type,
            file_type = _CONSTRUCTORS[file_type](**kwargs),
            runfiles = depset(transitive = runfiles),
        )
        files[f] = info
        extra_files.append(info)

    return depset(extra_files), generated

def resolve(file):
    if file.file_type_name == SYMLINK:
        return file.file_type.target
    return file

def get_file_type(file, file_type, follow_symlinks = True):
    if follow_symlinks:
        file = resolve(file)
    if file.file_type_name == file_type:
        return file.file_type

def filter_files(files, file_type, follow_symlinks = True):
    return [
        file
        for file in files
        if get_file_type(file, file_type, follow_symlinks) != None
    ]
