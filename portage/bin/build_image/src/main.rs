// Copyright 2022 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use anyhow::{ensure, Result};
use binarypackage::BinaryPackage;
use clap::Parser;
use cliutil::cli_main;
use container::{enter_mount_namespace, BindMount, CommonArgs, ContainerSettings};
use fileutil::resolve_symlink_forest;
use std::{
    path::{Path, PathBuf},
    process::ExitCode,
};

const MAIN_SCRIPT: &str = "/mnt/host/.build_image/build_image.sh";

#[derive(Parser, Debug)]
#[clap()]
pub struct Cli {
    #[command(flatten)]
    common: CommonArgs,

    /// Name of board
    #[arg(long, required = true)]
    board: String,

    /// Output file path.
    #[arg(long, required = true)]
    output: PathBuf,

    /// Image to build.
    #[arg(long, required = true)]
    image_to_build: String,

    /// The name of the image file generated by build_image script.
    #[arg(long, required = true)]
    image_file_name: String,

    /// File paths to binary packages to be installed on the output image.
    #[arg(long)]
    target_package: Vec<PathBuf>,

    /// File paths to host binary packages to be made available to the
    /// build_image script.
    #[arg(long)]
    host_package: Vec<PathBuf>,

    #[arg(long)]
    override_base_package: Vec<String>,
}

fn do_main() -> Result<()> {
    let args = Cli::parse();

    let mut settings = ContainerSettings::new();
    settings.apply_common_args(&args.common)?;

    let runfiles = runfiles::Runfiles::create()?;

    settings.push_bind_mount(BindMount {
        source: resolve_symlink_forest(
            &runfiles.rlocation("cros/bazel/portage/bin/build_image/container_files/edb_chromeos"),
        )?,
        mount_path: Path::new("/build")
            .join(&args.board)
            .join("var/cache/edb/chromeos"),
        rw: false,
    });
    settings.push_bind_mount(BindMount {
        source: resolve_symlink_forest(&runfiles.rlocation(
            "cros/bazel/portage/bin/build_image/container_files/package.accept_keywords",
        ))?,
        mount_path: Path::new("/build")
            .join(&args.board)
            .join("etc/portage/package.accept_keywords/accept_all"),
        rw: false,
    });
    settings.push_bind_mount(BindMount {
        source: resolve_symlink_forest(
            &runfiles
                .rlocation("cros/bazel/portage/bin/build_image/container_files/package.provided"),
        )?,
        mount_path: Path::new("/build")
            .join(&args.board)
            .join("etc/portage/profile/package.provided"),
        rw: false,
    });
    settings.push_bind_mount(BindMount {
        source: resolve_symlink_forest(
            &runfiles
                .rlocation("cros/bazel/portage/bin/build_image/container_files/build_image.sh"),
        )?,
        mount_path: PathBuf::from(MAIN_SCRIPT),
        rw: false,
    });

    for path in args.target_package {
        let path = resolve_symlink_forest(&path)?;
        let package = BinaryPackage::open(&path)?;
        let mount_path = Path::new("/build")
            .join(&args.board)
            .join("packages")
            .join(format!("{}.tbz2", package.category_pf()));
        settings.push_bind_mount(BindMount {
            mount_path,
            source: path,
            rw: false,
        });
    }

    for path in args.host_package {
        let path = resolve_symlink_forest(&path)?;
        let package = BinaryPackage::open(&path)?;
        let mount_path =
            Path::new("/var/lib/portage/pkgs").join(format!("{}.tbz2", package.category_pf()));
        settings.push_bind_mount(BindMount {
            mount_path,
            source: path,
            rw: false,
        });
    }

    let mut container = settings.prepare()?;

    let status = container
        .command(MAIN_SCRIPT)
        .arg("--board")
        .arg(&args.board)
        .arg(&args.image_to_build)
        .env("BASE_PACKAGE", args.override_base_package.join(" "))
        .status()?;

    ensure!(status.success());

    let path = Path::new("mnt/host/source/src/build/images")
        .join(&args.board)
        .join("latest")
        .join(args.image_file_name + ".bin");
    std::fs::copy(container.root_dir().join(path), args.output)?;

    Ok(())
}

fn main() -> ExitCode {
    enter_mount_namespace().expect("Failed to enter a mount namespace");
    cli_main(do_main, Default::default())
}
