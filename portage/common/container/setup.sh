#!/bin/bash -e
# Copyright 2022 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

set -eu -o pipefail

declare -a args=("$@")

# Check if we're running in an interactive mode.
if [[ -v _LOGIN_MODE ]]; then
  readonly login_mode="${_LOGIN_MODE}"
  readonly login_term="${_TERM-}"
  readonly login_terminfo="${_TERMINFO-}"
  # Remove our private variables from the environment.
  unset _LOGIN_MODE _TERM _TERMINFO
else
  readonly login_mode=
  readonly login_term=
  readonly login_terminfo=
fi

# In non-interactive mode, print all outputs to stderr to avoid shuffled logs in
# Bazel output.
if [[ -z "${login_mode}" ]]; then
  exec >&2
  echo "NOTE: Redirecting stdout to stderr in non-interactive sessions"
fi

# Environment variables common to all containers.
# Do not set ROOT, SYSROOT, PORTAGE_CONFIGROOT here! They are confusing when
# developers enter a container with an interactive shell and run Portage tools.
export LANG=en_US.UTF-8
export PORTAGE_USERNAME=root
export PORTAGE_GRPNAME=root
export RESTRICT="fetch binchecks"
export FEATURES="binpkg-hermetic -sandbox -usersandbox -ipc-sandbox -mount-sandbox -network-sandbox -pid-sandbox"
export CCACHE_DISABLE=1

start_debug_shell() {
  echo
  echo "======================================================================="
  echo
  echo "Entering an interactive shell in the ephemeral CrOS SDK container."
  echo
  echo "This is the main command that was/will be run in the container:"
  echo "  ${args[*]@Q}"
  echo
  echo "Happy debugging!"

  local env=()
  if [[ -n "${login_term}" ]]; then
    env+=(TERM="${login_term}")
  fi

  if [[ -n "${login_terminfo}" ]]; then
    env+=(TERMINFO="${login_terminfo}")
  fi

  env "${env[@]}" bash || :

  # When bash runs in interactive mode, it creates a new processes group
  # id (PGID) and sets the terminal's processes group id (TPGID) to the newly
  # created processes group id. This allows the signals generated by Ctrl+C,
  # Ctrl+Z, etc to be handled correctly. When bash exits, the TPGID will be
  # left pointing to the terminated processes, so we need to update the TPGID
  # to restore correct signal keyboard signal handling. Ideally we can just
  # restore the TPGID that was set before we invoked bash, which is the same as
  # the PGID that this script is currently executing as. The problem is that
  # `tcgetpgrp` returns 0 because the PGID that we are executing with was
  # created outside of the PID namespace, so we no longer have access to it.
  #
  # Notify the ancestor that is outside the container to reset the TPGID
  printf 't' > /.control
}

if [[ "${login_mode}" == "before" ]]; then
  start_debug_shell
fi

echo ">>> ${args[*]}"

if [[ -z "${login_mode}" ]]; then
  exec "${args[@]}"
fi

if "${args[@]}"; then
  readonly rc=0
else
  readonly rc="$?"
fi

if [[ "${login_mode}" == "after" || \
      "${login_mode}" == "after-fail" && "${rc}" -ne 0 ]]; then
  start_debug_shell
fi

exit "${rc}"
