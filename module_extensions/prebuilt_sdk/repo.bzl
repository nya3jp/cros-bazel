# Copyright 2023 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

load("//bazel/repo_defs:gs.bzl", "GS_ATTRS", "download_gs_file")

visibility("private")

_HEADER = """# Copyright 2023 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Autogenerated. Do not edit."""

_PACKAGE_FORMAT = _HEADER + """
load("@@//bazel/portage/build_defs:binary_package.bzl", "binary_package")
load("@@//bazel/portage/build_defs:extract_package_from_manifest.bzl", "filter_package")

binary_package(
    name = "binpkg",
    package_name = {package_name},
    src = {src},
    category = {category},
    slot = {full_slot},
    version = {version},
    visibility = ["//:__subpackages__"],
    runtime_deps = {runtime_deps},
)

filter_package(
    name = {name},
    package_name = {category} + "/" + {package_name},
    interface = "//:extracted_sysroot",
    slot = {main_slot},
    visibility = ["//visibility:public"],
)
"""

_ROOT_BUILD_FILE = _HEADER + """
load("@@//bazel/build_defs:packed_binary.bzl", "unpack_binary")
load("@@//bazel/portage/build_defs:extract_package_from_manifest.bzl", "extract_package")
load(":manifest.bzl", "FILE_MANIFEST_CONTENT")

alias(
    name = "sysroot",
    actual = {root_package},
)

unpack_binary(
    name = "extractor",
    src = {extractor},
)

extract_package(
    name = "extracted_sysroot",
    # This is only used for regeneration, which can't happen in an already
    # generated repo rule.
    header_file_dir_regexes = [],
    extractor = ":extractor",
    # This is only used for regeneration, which can't happen in an already
    # generated repo rule.
    ld_library_path_regexes = [],
    manifest_content = FILE_MANIFEST_CONTENT,
    manifest_file = ":manifest.bzl",
    pkg = ":sysroot",
    visibility = ["//visibility:public"],
)
"""

# "gs://bucket/foo/bar/<checksum>.ext" -> "foo_bar_<checksum>"
def repo_name(uri):
    if not uri.startswith("gs://"):
        fail("Invalid uri %s" % uri)
    parts = uri.split("/")
    prefix = "_".join(parts[3:-1])
    checksum = parts[-1].split(".")[0]
    return "%s_%s" % (prefix, checksum)

# "gs://bucket/prebuilts/<cat>/<pkg>/<checksum>.ext" -> "<cat>/<pkg>"
def _package_name(uri):
    if "/prebuilts/" not in uri:
        fail("Invalid package name: " + uri)
    return uri.split("/prebuilts/", 1)[1].rsplit("/", 1)[0]

def _prebuilt_sdk_repo_impl(repo_ctx):
    repo_ctx.file("WORKSPACE.bazel", "")

    download_gs_file(repo_ctx)
    remote_manifest = json.decode(repo_ctx.read("file/%s" % repo_ctx.attr.downloaded_file_path))

    manifest_json = json.encode(remote_manifest["manifest"])
    repo_ctx.file(
        "manifest.bzl",
        'FILE_MANIFEST_CONTENT = json.decode("""%s""")\n' % manifest_json,
    )

    pkgs = remote_manifest["providers"]
    extractor_repo = repo_name(remote_manifest["extractor"])

    # Packages must be in valid installation order. This implies that the root
    # package must be the final one.
    root_label = "//%s:binpkg" % _package_name(pkgs[-1]["uri"])
    repo_ctx.file(
        "BUILD.bazel",
        _ROOT_BUILD_FILE.format(
            root_package = repr(root_label),
            extractor = repr("@prebuilt_sdk_tarballs//:%s" % extractor_repo),
        ),
    )

    for pkg in pkgs:
        dir = _package_name(pkg["uri"])
        tarball_src = "@prebuilt_sdk_tarballs//:%s" % repo_name(pkg["uri"])
        repo_ctx.file(
            dir + "/BUILD.bazel",
            _PACKAGE_FORMAT.format(
                name = repr(dir.split("/")[-1]),
                src = repr(tarball_src),
                category = repr(pkg["category"]),
                package_name = repr(pkg["package_name"]),
                version = repr(pkg["version"]),
                full_slot = repr(pkg["slot"]),
                main_slot = repr(pkg["slot"].split("/")[0]),
                runtime_deps = repr([
                    "//%s:binpkg" % _package_name(dep)
                    for dep in pkg["direct_runtime_deps"]
                ]),
            ),
        )

prebuilt_sdk_repo = repository_rule(
    implementation = _prebuilt_sdk_repo_impl,
    attrs = GS_ATTRS,
)
