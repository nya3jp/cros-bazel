# Copyright 2023 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_file")
load("//bazel:repo/cipd.bzl", "cipd_file")
load("//bazel:repo/repo_repository.bzl", "repo_repository")
load("//bazel/chrome:cros_chrome_repository.bzl", "cros_chrome_repository")
load("//bazel/module_extensions/portage:alchemist.bzl", "alchemist")
load("//bazel/module_extensions/portage:portage_digest.bzl", "portage_digest")
load("//bazel/module_extensions/portage:portage_tarball.bzl", "portage_tarball")
load("//bazel/module_extensions/private:extract_tarball.bzl", "extract_tarball")

"""Module extensions to generate the @portage repo.

We have to split this into 2 extensions, because module extensions cannot read
any files generated by repos declared in their own module extension (this would
create circular dependencies). However, they can read files generated by repos
declared in other module extensions."""

_RULE_MAPPING = {
    "CipdFile": cipd_file,
    "CrosChromeRepository": cros_chrome_repository,
    "HttpFile": http_file,
    "RepoRepository": repo_repository,
}

def _pre_portage_impl(module_ctx):
    alchemist(name = "alchemist")
    portage_digest(
        name = "portage_digest",
        alchemist = "@alchemist//:alchemist",
    )

    # Ideally, we'd just generate the directory from inside the module
    # extension, then read deps.json and generate one repo per dependency.
    # However, until github.com/bazelbuild/bazel/issues/14554 is released,
    # bzlmod won't cache module extension results. This means that if the module
    # extension is rerun, even if it generates the exact same repo rules, it
    # will rerun the repo rules regardless.

    # So for now, we just do a hack where we tar it up and untar it again, to
    # deal with the visibility issues (both @portage and the deps need to be
    # generated in the same module extension for @portage to see the deps).
    portage_tarball(
        name = "portage_tarball",
        board = "@portage_digest//:board",
        profile = "@portage_digest//:profile",
        digest = "@portage_digest//:digest",
        alchemist = "@alchemist//:alchemist",
    )

pre_portage = module_extension(
    implementation = _pre_portage_impl,
)

def _portage_impl(module_ctx):
    deps_path = module_ctx.path(Label("@portage_tarball//:deps.json"))
    extract_tarball(name = "portage", tarball = "@portage_tarball//:repo.tar.gz")

    # TODO: Create a hub repo @portage_deps which aliases to each of these
    #  spokes. Then @portage can be generated directly in the previous step - no
    #  need to tar and untar.
    deps = json.decode(module_ctx.read(deps_path))
    for repo in deps:
        for rule, kwargs in repo.items():
            _RULE_MAPPING[rule](**kwargs)

portage = module_extension(
    implementation = _portage_impl,
)
