#!/bin/bash -ex
# Copyright 2022 The ChromiumOS Authors.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# HACK: Print all outputs to stderr to avoid shuffled logs in Bazel output.
if [[ $# -gt 0 ]]; then
  exec >&2
fi

export LANG=en_US.UTF-8
export ROOT="/build/${BOARD}/"
export SYSROOT="${ROOT}"
export PORTAGE_CONFIGROOT="${ROOT}"
export PORTAGE_USERNAME=root
export PORTAGE_GRPNAME=root
export RESTRICT="fetch binchecks"
export FEATURES="binpkg-hermetic -sandbox -usersandbox -ipc-sandbox -mount-sandbox -network-sandbox -pid-sandbox"
export CCACHE_DISABLE=1

if [[ -v _LOGIN_MODE ]]; then
  LOGIN_MODE="${_LOGIN_MODE}"
  # Remove our private variable from the environment
  unset _LOGIN_MODE
else
  LOGIN_MODE=""
fi

invoke-bash() {
  # TODO: When bash runs in interactive mode, it creates a new processes group
  # id (PGID) and sets the terminal's processes group id (TPGID) to the newly
  # created processes group id. This allows the signals generated by Ctrl+C,
  # Ctrl+Z, etc to be handled correctly. When bash exits, the TPGID will be
  # left pointing to the terminated processes, so we need to update the TPGID
  # to restore correct signal keyboard signal handling. Ideally we can just
  # restore the TPGID that was set before we invoked bash, which is the same as
  # the PGID that this script is currently executing as. The problem is that
  # `tcgetpgrp` returns 0 because the PGID that we are executing with was
  # created outside of the PID namespace, so we no longer have access to it.
  # This means that once bash runs, Ctrl+C won't work until control is returned
  # to the parent shell.
  bash || true
}

if [[ "${LOGIN_MODE}" == "before-deps" ]]; then
  invoke-bash
fi

install_deps() {
  local -i idx=0

  while [[ -v "INSTALL_ATOMS_TARGET_${idx}" ]]; do
    local -a atoms
    local current_group_var="INSTALL_ATOMS_TARGET_${idx}"

    read -ra atoms <<<"${!current_group_var}"
    if [[ "${#atoms[@]}" -gt 0 ]]; then
      # We need to unmask the -9999 cros-workon ebuilds so we can install them
      mkdir -p "${ROOT}/etc/portage/package.accept_keywords"
      printf "%s\n" "${atoms[@]}" \
        >> "${ROOT}/etc/portage/package.accept_keywords/cros-workon"
      # Use fakeroot on installing build dependencies since some files might
      # have non-root ownership or special permissions. Hopefully this does not
      # affect the result of building the package.
      # TODO: emerge is too slow! Find a way to speed up.
      time fakeroot emerge --oneshot --usepkgonly --nodeps --noreplace --jobs \
        "${atoms[@]}"
    fi
    unset "${current_group_var}"
    idx+=1
  done
}

install_deps

# cros_sdk will bind mount depot_tools to /mnt/host/depot_tools. This is only
# needed for chrome and chrome-icu. Since chromium includes depot_tools, we can
# just use that.
if [[ -d /home/root/chrome_root/src/third_party/depot_tools ]]; then
  mkdir -p /mnt/host
  ln -s /home/root/chrome_root/src/third_party/depot_tools /mnt/host/depot_tools
  # The src tarball has already had the hooks ran, so no need to run it in the
  # ebuild. It also won't run in the ebuild since the hooks need to access
  # the network.
  export USE="-runhooks ${USE}"
  # Use the CIPD cache provided by the tarball to avoid network access.
  export CIPD_CACHE_DIR="/home/root/chrome_root/.cipd-cache"
fi

export FEATURES="${FEATURES} fakeroot"

if [[ "${LOGIN_MODE}" == "before" ]]; then
  invoke-bash
fi

if [[ $# = 0 ]]; then
  exec bash
elif [[ -z "${LOGIN_MODE}" ]]; then
  exec "$@"
fi

if "$@"; then
  RC=0
else
  RC="$?"
fi

if [[ "${LOGIN_MODE}" == "after" ]]; then
  invoke-bash
elif [[ "${LOGIN_MODE}" == "after-fail" && "$RC" -ne 0 ]]; then
  invoke-bash
fi

exit $RC
