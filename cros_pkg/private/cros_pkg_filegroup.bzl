# Copyright 2023 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

load("@rules_pkg//pkg:mappings.bzl", _strip_prefix = "strip_prefix")
load("@rules_pkg//pkg:providers.bzl", "PackageDirsInfo", "PackageFilegroupInfo", "PackageFilesInfo", "PackageSymlinkInfo")
load("@rules_pkg//pkg:tar.bzl", "pkg_tar")
load(":pkg_files.bzl", "pkg_attributes", "pkg_files_impl")

def _gen_fake_ctx(ctx, src, metadata):
    """Generates a fake ctx-like object suitable for use with pkg_files_impl."""
    metadata = json.decode(metadata)
    attributes = pkg_attributes(
        mode = metadata.get("mode", None),
        user = metadata.get("user", None),
        group = metadata.get("group", None),
        uid = metadata.get("uid", None),
        gid = metadata.get("gid", None),
    )
    strip_prefix = metadata.get("strip_prefix", _strip_prefix.files_only())

    renames = {}
    if "name" in metadata:
        renames[src] = metadata["name"]

    return struct(
        files = struct(
            srcs = src.files.to_list(),
            excludes = [],
        ),
        attr = struct(
            strip_prefix = strip_prefix,
            prefix = metadata["prefix"],
            attributes = attributes,
            renames = renames,
        ),
    )

def _cros_pkg_filegroup_impl(ctx):
    files = []

    pkg_files = []
    for target in ctx.attr.pkg_files:
        pkg_files.append((target[PackageFilesInfo], target.label))
        files.append(target[DefaultInfo].files)
    pkg_dirs = []
    for target in ctx.attr.pkg_dirs:
        pkg_dirs.append((target[PackageDirsInfo], target.label))
        files.append(target[DefaultInfo].files)
    pkg_symlinks = []
    for target in ctx.attr.pkg_symlinks:
        pkg_symlinks.append((target[PackageSymlinkInfo], target.label))
        files.append(target[DefaultInfo].files)

    if ctx.attr.pkg_filegroups:
        for filegroup in ctx.attr.pkg_filegroups:
            files.append(filegroup[DefaultInfo].files)
            provider = filegroup[PackageFilegroupInfo]
            pkg_dirs.extend(provider.pkg_dirs)
            pkg_files.extend(provider.pkg_files)
            pkg_symlinks.extend(provider.pkg_symlinks)

    for src, metadata in ctx.attr.srcs.items():
        if PackageFilegroupInfo in src or PackageFilesInfo in src or PackageDirsInfo in src or PackageSymlinkInfo in src:
            fail("{} has unexpected provider. Use pkg_[files|dirs|symlinks|filegroups]".format(str(src.label)))
        package_files_info, default_info = pkg_files_impl(_gen_fake_ctx(ctx, src, metadata))
        files.append(default_info.files)
        pkg_files.append((package_files_info, src.label))

    return [
        DefaultInfo(
            files = depset(transitive = files),
        ),
        PackageFilegroupInfo(
            pkg_dirs = pkg_dirs,
            pkg_files = pkg_files,
            pkg_symlinks = pkg_symlinks,
        ),
    ]

_cros_pkg_filegroup = rule(
    implementation = _cros_pkg_filegroup_impl,
    attrs = dict(
        srcs = attr.label_keyed_string_dict(allow_files = True),
        pkg_files = attr.label_list(providers = [PackageFilesInfo]),
        pkg_dirs = attr.label_list(providers = [PackageDirsInfo]),
        pkg_symlinks = attr.label_list(providers = [PackageSymlinkInfo]),
        pkg_filegroups = attr.label_list(providers = [PackageFilegroupInfo]),
    ),
)

def cros_pkg_filegroup(name, srcs = [], dst = None, **kwargs):
    # Bazel doesn't support arbitrary types like Dict[string, List[Label]].
    # So we're stuck with converting this to a "label_keyed_string_dict".
    label_keyed_srcs = {}
    if dst:
        if "name" in kwargs or "prefix" in kwargs or "strip_prefix" in kwargs:
            fail("Name, prefix, and strip_prefix are incompatible with dst")
        kwargs["prefix"], kwargs["name"] = dst.rsplit("/", 1)
        kwargs["strip_prefix"] = _strip_prefix.files_only()

    for src in srcs:
        if not hasattr(src, "srcs") or not hasattr(src, "kwargs"):
            fail("Each entry in srcs should be an object generated by bazel package helper functions (eg. bin, exe, file, doc).")

        if len(src.srcs) > 1 and "name" in kwargs:
            fail("Cannot rename a file when multiple files are specified at once (in {})".format(name))

        for label in src.srcs:
            if label in label_keyed_srcs:
                fail("{} is specified twice in the pkg's filegroup. If this is intended, consider splitting one of them out into a rules_pkg invocation directly, and adding pkg_files = [...] to the cros_pkg_filegroup invocation.".format(label))
            label_keyed_srcs[label] = src.kwargs

    _cros_pkg_filegroup(
        name = name,
        srcs = label_keyed_srcs,
        **kwargs
    )

    pkg_tar(name = name + "_tar", srcs = [name], out = name + ".tar")

def custom_file_type(**defaults):
    def fn(srcs, **kwargs):
        return struct(
            srcs = srcs,
            kwargs = json.encode(defaults | kwargs),
        )

    return fn

def unimplemented(message = "Not implemented yet"):
    def fn(srcs, **kwargs):
        fail(message)

    return fn
