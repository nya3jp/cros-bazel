#!/usr/bin/env python3
# Copyright 2023 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""The entrypoint to bazel.

This script adds various chromeos-specific command-line options.
"""

import getpass
import hashlib
import itertools
import json
import os
import pathlib
import subprocess
import sys
import time
from typing import List


_INVOCATION_NAME_PREFIX = "invocations/build-"


def fail(msg: str):
    print(f"ERROR: {msg}", file=sys.stderr)
    sys.exit(1)


def get_workspace() -> pathlib.Path:
    cwd = pathlib.Path.cwd()
    for parent in itertools.chain([cwd], cwd.parents):
        if parent.joinpath(".repo").is_dir():
            return parent.joinpath("src").resolve()
    fail("Working directory is not a bazel workspace")


def main(args: List[str]):
    # We expect BAZEL_REAL to be set by Bazel.
    bazel_real = os.environ.get("BAZEL_REAL", None)
    if not bazel_real:
        fail("BAZEL_REAL must be set.")

    # Allow users to have a bazelrc file shared between all chromiumos
    # checkouts, since ~/.bazelrc also has non-chromiumos stuff.
    startup_options = []
    chromiumos_rc = os.path.expanduser("~/.chromiumos.bazelrc")
    if os.path.exists(chromiumos_rc):
        startup_options.append(f"--bazelrc={chromiumos_rc}")

    command = None
    command_options = []
    nested_command_options = []
    for i, arg in enumerate(args):
        if arg.startswith("--"):
            startup_options.append(arg)
        else:
            command = args[i]
            command_args = args[i + 1 :]
            break
    if command is None:
        # Let bazel display its own error listing available commands.
        os.execv(bazel_real, [bazel_real, *startup_options])

    # Used to force the alchemist_digest repo rule to re-run every
    # invocation.
    cache_bust_date = os.environ.get("CACHE_BUST_DATE", f"{time.time():.9f}")
    command_options.append(f"--repo_env=CACHE_BUST_DATE={cache_bust_date}")

    # Append the current ci.chromium.org build id, if this is a CI build.
    # More info:
    # https://chromium.googlesource.com/infra/luci/luci-py/+/HEAD/client/LUCI_CONTEXT.md
    #
    # TODO(b/311706335): Read the buildbucket ID from BAPI instead of
    # LUCI_CONTEXT
    # when that's available.
    luci_context = os.environ.get("LUCI_CONTEXT", None)
    if luci_context is not None:
        # Match the ID group: "invocations/build-<ID>" from the resultDB field.
        with open(luci_context, "r", encoding="utf-8") as f:
            invocation_name = json.load(f)["resultdb"]["current_invocation"][
                "name"
            ]
            if not invocation_name.startswith(_INVOCATION_NAME_PREFIX):
                fail(f"Invalid invocation name {invocation_name!r}")
            buildbucket_id = int(
                invocation_name[len(_INVOCATION_NAME_PREFIX) :]
            )
            opt = (
                "--build_metadata=cros/luci/build_url="
                f"https://ci.chromium.org/ui/b/{buildbucket_id}"
            )
            command_options.append(opt)
            nested_command_options.append(opt)

    workspace = get_workspace()
    checksum = hashlib.md5(str(workspace).encode("utf-8")).hexdigest()
    nested_output_base = os.path.expanduser(
        f"~/.cache/bazel/bazel_{getpass.getuser()}/{checksum}_nested"
    )
    nested_base_command = [
        bazel_real,
        "--output_base",
        nested_output_base,
        *startup_options,
    ]
    build = [
        *nested_base_command,
        "build",
        *nested_command_options,
        "--platforms=@@//bazel/platforms:host",
    ]
    command_options.append(f"--repo_env=NESTED_BAZEL_CMD={json.dumps(build)}")

    if command == "shutdown":
        print("Shutting down nested bazel server")
        subprocess.run(
            [*nested_base_command, "shutdown", *nested_command_options],
            check=True,
        )
        print("Shutting down main bazel server")
    else:
        # Repo rules are run in a process wrapper, and the "child subreaper"
        # ensures that the bazel server is killed after the repo rule finishes.
        # See github.com/bazelbuild/bazel/issues/20447
        # To solve this, we just start the nested server on every bazel
        # invocation by running "bazel version" to ensure it's allways running.

        # This is too slow for the hot path, so we detach it. We technically
        # could hit a race condition where the server is started by the repo
        # rule rather than here, but it:
        # * Doesn't affect correctness, only the performance of that invocation.
        # * Will be corrected in the following invocation.
        # * Is very rare.
        # pylint: disable=consider-using-with
        subprocess.Popen(
            [*nested_base_command, "version", *nested_command_options],
            stdout=subprocess.DEVNULL,
            # Otherwise we get two "starting bazel server and connecting".
            stderr=subprocess.DEVNULL,
            close_fds=True,
        )

    argv_real = [
        bazel_real,
        *startup_options,
        command,
        *command_options,
        *command_args,
    ]
    os.execv(bazel_real, argv_real)


if __name__ == "__main__":
    main(sys.argv[1:])
